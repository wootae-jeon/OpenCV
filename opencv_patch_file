diff -urPx build -x .git opencv_old/.cache/.gitignore opencv/.cache/.gitignore
--- opencv_old/.cache/.gitignore	1970-01-01 09:00:00.000000000 +0900
+++ opencv/.cache/.gitignore	2019-12-20 15:08:11.830249077 +0900
@@ -0,0 +1 @@
+*
Binary files opencv_old/modules/python/src2/hdr_parser.pyc and opencv/modules/python/src2/hdr_parser.pyc differ
diff -urPx build -x .git opencv_old/modules/videoio/include/opencv2/videoio.hpp opencv/modules/videoio/include/opencv2/videoio.hpp
--- opencv_old/modules/videoio/include/opencv2/videoio.hpp	2019-12-20 16:47:34.945180287 +0900
+++ opencv/modules/videoio/include/opencv2/videoio.hpp	2019-12-26 14:54:34.672644160 +0900
@@ -640,6 +640,7 @@
     @sa The list of supported API backends cv::VideoCaptureAPIs
     */
     CV_WRAP VideoCapture(int index);
+    CV_WRAP VideoCapture(int index, int change_buffer_size, int buffer_size);
 
     /** @brief Default destructor
 
@@ -668,6 +669,7 @@
     The method first calls VideoCapture::release to close the already opened file or camera.
     */
     CV_WRAP virtual bool open(int index);
+    CV_WRAP virtual bool open(int index, int change_buffer_size, int buffer_size);
 
    /** @brief  Open a camera for video capturing
 
Binary files opencv_old/modules/videoio/include/opencv2/.videoio.hpp.swp and opencv/modules/videoio/include/opencv2/.videoio.hpp.swp differ
diff -urPx build -x .git opencv_old/modules/videoio/src/cap.cpp opencv/modules/videoio/src/cap.cpp
--- opencv_old/modules/videoio/src/cap.cpp	2019-12-20 16:47:34.949180484 +0900
+++ opencv/modules/videoio/src/cap.cpp	2019-12-20 15:11:34.565597816 +0900
@@ -284,7 +284,33 @@
 
     return capture;
 }
+CV_IMPL CvCapture * cvCreateCameraCapture_buffer_size (int index, int change_buffer_size, int buffer_size)
+{
+    // interpret preferred interface (0 = autodetect)
+    int pref = (index / 100) * 100;
+
+    // remove pref from index
+    index -= pref;
+
+    // local variable to memorize the captured device
+    CvCapture *capture = 0;
+
+    switch (pref)
+    {
+    default:
+        // user specified an API we do not know
+        // bail out to let the user know that it is not available
+        if (pref) break;
+
+    case CAP_VFW: // or CAP_V4L or CAP_V4L2
+#if defined HAVE_LIBV4L || defined HAVE_CAMV4L || defined HAVE_CAMV4L2 || defined HAVE_VIDEOIO
+        TRY_OPEN(capture, cvCreateCameraCapture_V4L_buffer_size(index,change_buffer_size,buffer_size))
+#endif
+
+    }
 
+    return capture;
+}
 /**
  * Videoreader dispatching method: it tries to find the first
  * API that can access a given filename.
@@ -612,6 +638,12 @@
     open(index);
 }
 
+VideoCapture::VideoCapture(int index, int change_buffer, int buffer_size)
+{
+	CV_TRACE_FUNCTION();
+	open(index, change_buffer, buffer_size);
+}
+
 VideoCapture::~VideoCapture()
 {
     CV_TRACE_FUNCTION();
@@ -651,6 +683,17 @@
     cap.reset(cvCreateCameraCapture(index));
     return isOpened();
 }
+bool VideoCapture::open(int index, int change_buffer_size, int buffer_size)
+{
+    CV_TRACE_FUNCTION();
+
+    if (isOpened()) release();
+    icap = IVideoCapture_create(index);
+    if (!icap.empty())
+        return true;
+    cap.reset(cvCreateCameraCapture_buffer_size(index, change_buffer_size, buffer_size));
+    return isOpened();
+}
 bool  VideoCapture::open(int cameraNum, int apiPreference)
 {
     CV_TRACE_FUNCTION();
diff -urPx build -x .git opencv_old/modules/videoio/src/cap_libv4l.cpp opencv/modules/videoio/src/cap_libv4l.cpp
--- opencv_old/modules/videoio/src/cap_libv4l.cpp	2019-12-26 13:35:24.712881095 +0900
+++ opencv/modules/videoio/src/cap_libv4l.cpp	2019-12-26 15:02:41.021148538 +0900
@@ -292,7 +292,9 @@
   size_t  length;
 };
 static unsigned int n_buffers = 0;
-
+int FirstRead=1;
+int SYNC_FETCH=0;
+int changed_buffer_size;
 /* TODO: Dilemas: */
 /* TODO: Consider drop the use of this data structure and perform ioctl to obtain needed values */
 /* TODO: Consider at program exit return controls to the initial values - See v4l2_free_ranges function */
@@ -357,6 +359,7 @@
 static int icvGrabFrameCAM_V4L( CvCaptureCAM_V4L* capture );
 static IplImage* icvRetrieveFrameCAM_V4L( CvCaptureCAM_V4L* capture, int );
 CvCapture* cvCreateCameraCapture_V4L( int index );
+CvCapture* cvCreateCameraCapture_V4L_buffer_size( int index, int change_buffer_size, int buffer_size);
 
 static double icvGetPropertyCAM_V4L( CvCaptureCAM_V4L* capture, int property_id );
 static int    icvSetPropertyCAM_V4L( CvCaptureCAM_V4L* capture, int property_id, double value );
@@ -774,7 +777,8 @@
 
    CLEAR (capture->req);
 
-   unsigned int buffer_number = DEFAULT_V4L_BUFFERS;
+   //unsigned int buffer_number = DEFAULT_V4L_BUFFERS;
+   unsigned int buffer_number = changed_buffer_size;
 
    try_again:
 
@@ -1103,97 +1107,187 @@
 #ifdef HAVE_CAMV4L2
 
 static int read_frame_v4l2(CvCaptureCAM_V4L* capture) {
-    struct v4l2_buffer buf;
-
-    CLEAR (buf);
-
-    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    buf.memory = V4L2_MEMORY_MMAP;
-
-    if (-1 == xioctl (capture->deviceHandle, VIDIOC_DQBUF, &buf)) {
-        switch (errno) {
-        case EAGAIN:
-            return 0;
-
-        case EIO:
-            /* Could ignore EIO, see spec. */
-
-            /* fall through */
-
-        default:
-            /* display the error and stop processing */
-            capture->returnFrame = false;
-            perror ("VIDIOC_DQBUF");
-            return -1;
-        }
+	//printf("SYNC_FETCH :%d\n", SYNC_FETCH);
+	if(!SYNC_FETCH){
+	    struct v4l2_buffer buf;
+	
+	    CLEAR (buf);
+	
+	    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	    buf.memory = V4L2_MEMORY_MMAP;
+	
+	    if (-1 == xioctl (capture->deviceHandle, VIDIOC_DQBUF, &buf)) {
+	        switch (errno) {
+	        case EAGAIN:
+	            return 0;
+	
+	        case EIO:
+	            /* Could ignore EIO, see spec. */
+	
+	            /* fall through */
+	
+	        default:
+	            /* display the error and stop processing */
+	            capture->returnFrame = false;
+	            perror ("VIDIOC_DQBUF");
+	            return -1;
+	        }
+	   }
+	
+	   assert(buf.index < capture->req.count);
+	
+	#ifdef USE_TEMP_BUFFER
+	   memcpy(capture->buffers[MAX_V4L_BUFFERS].start,
+	    capture->buffers[buf.index].start,
+	    capture->buffers[MAX_V4L_BUFFERS].length );
+	   capture->bufferIndex = MAX_V4L_BUFFERS;
+//	   printf("got data in buff %d, len=%d, flags=0x%X, seq=%d, used=%d)\n",
+//	      buf.index, buf.length, buf.flags, buf.sequence, buf.bytesused);
+	#else
+	   capture->bufferIndex = buf.index;
+	#endif
+	   capture->timestamp = buf.timestamp;   //printf( "timestamp update done \n");
+	   capture->sequence = buf.sequence;
+	
+	   if (-1 == xioctl (capture->deviceHandle, VIDIOC_QBUF, &buf))
+	       perror ("VIDIOC_QBUF");
+	
+	   //set timestamp in capture struct to be timestamp of most recent frame
+	   /** where timestamps refer to the instant the field or frame was received by the driver, not the capture time*/
+	
+	   return 1;
+	}else{
+	    struct v4l2_buffer buf;
+	    CLEAR (buf);
+	
+	    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	    buf.memory = V4L2_MEMORY_MMAP;
+	    buf.index=0;
+	
+	    if(!FirstRead){
+		    if (-1 == xioctl (capture->deviceHandle, VIDIOC_QBUF, &buf)){
+		        perror ("VIDIOC_QBUF");
+		        return 0;
+		    }
+	    }
+	    else FirstRead=0;
+	
+	    fd_set fds;
+	    struct timeval tv;
+	    int r;
+	
+	    FD_ZERO (&fds);
+	    FD_SET (capture->deviceHandle, &fds);
+	
+	    /* Timeout. */
+	    tv.tv_sec = 10;
+	    tv.tv_usec = 0;
+	
+	    r = select (capture->deviceHandle+1, &fds, NULL, NULL, &tv);
+	
+	    if (-1 == r) 
+	        perror ("select");
+	
+	    if (0 == r) 
+	        fprintf (stderr, "select timeout\n");
+	
+	
+	
+	    if (-1 == xioctl (capture->deviceHandle, VIDIOC_DQBUF, &buf)) {
+	        switch (errno) {
+	        case EAGAIN:
+	            return 0;
+	
+	        case EIO:
+	            /* Could ignore EIO, see spec. */
+	
+	            /* fall through */
+	
+	        default:
+	            /* display the error and stop processing */
+	            capture->returnFrame = false;
+	            perror ("VIDIOC_DQBUF");
+	            return -1;
+	        }
+	   }
+	
+	   assert(buf.index < capture->req.count);
+	
+	#ifdef USE_TEMP_BUFFER
+	   memcpy(capture->buffers[MAX_V4L_BUFFERS].start,
+	    capture->buffers[buf.index].start,
+	    capture->buffers[MAX_V4L_BUFFERS].length );
+	   capture->bufferIndex = MAX_V4L_BUFFERS;
+//	   printf("go data in buff %d, len=%d, flags=0x%X, seq=%d, used=%d)\n",
+//	      buf.index, buf.length, buf.flags, buf.sequence, buf.bytesused);
+	#else
+	   capture->bufferIndex = buf.index;
+	#endif
+	   //set timestamp in capture struct to be timestamp of most recent frame
+	   /** where timestamps refer to the instant the field or frame was received by the driver, not the capture time*/
+	   capture->timestamp = buf.timestamp;   //printf( "timestamp update done \n");
+	   capture->sequence = buf.sequence;
+	
+	   return 1;
    }
 
-   assert(buf.index < capture->req.count);
-
-#ifdef USE_TEMP_BUFFER
-   memcpy(capture->buffers[MAX_V4L_BUFFERS].start,
-    capture->buffers[buf.index].start,
-    capture->buffers[MAX_V4L_BUFFERS].length );
-   capture->bufferIndex = MAX_V4L_BUFFERS;
-   //printf("got data in buff %d, len=%d, flags=0x%X, seq=%d, used=%d)\n",
-   //   buf.index, buf.length, buf.flags, buf.sequence, buf.bytesused);
-#else
-   capture->bufferIndex = buf.index;
-#endif
-
-   if (-1 == xioctl (capture->deviceHandle, VIDIOC_QBUF, &buf))
-       perror ("VIDIOC_QBUF");
-
-   //set timestamp in capture struct to be timestamp of most recent frame
-   /** where timestamps refer to the instant the field or frame was received by the driver, not the capture time*/
-   capture->timestamp = buf.timestamp;   //printf( "timestamp update done \n");
-   capture->sequence = buf.sequence;
-
-   return 1;
+    
 }
 
 static int mainloop_v4l2(CvCaptureCAM_V4L* capture) {
     unsigned int count;
 
     count = 1;
-
-    while (count-- > 0) {
-        for (;;) {
-            fd_set fds;
-            struct timeval tv;
-            int r;
-
-            FD_ZERO (&fds);
-            FD_SET (capture->deviceHandle, &fds);
-
-            /* Timeout. */
-            tv.tv_sec = 10;
-            tv.tv_usec = 0;
-
-            r = select (capture->deviceHandle+1, &fds, NULL, NULL, &tv);
-
-            if (-1 == r) {
-                if (EINTR == errno)
-                    continue;
-
-                perror ("select");
-            }
-
-            if (0 == r) {
-                fprintf (stderr, "select timeout\n");
-
-                /* end the infinite loop */
-                break;
-            }
-
-            int returnCode=read_frame_v4l2(capture);
-            if (returnCode == -1)
-                return -1;
-            if (returnCode == 1)
-                return 0;
-        }
-    }
-    return 0;
+	if(!SYNC_FETCH){
+	    while (count-- > 0) {
+	        for (;;) {
+	            fd_set fds;
+	            struct timeval tv;
+	            int r;
+	
+	            FD_ZERO (&fds);
+	            FD_SET (capture->deviceHandle, &fds);
+	
+	            /* Timeout. */
+	            tv.tv_sec = 10;
+	            tv.tv_usec = 0;
+	
+	            r = select (capture->deviceHandle+1, &fds, NULL, NULL, &tv);
+	
+	            if (-1 == r) {
+	                if (EINTR == errno)
+	                    continue;
+	
+	                perror ("select");
+	            }
+	
+	            if (0 == r) {
+	                fprintf (stderr, "select timeout\n");
+	
+	                /* end the infinite loop */
+	                break;
+	            }
+	
+	            int returnCode=read_frame_v4l2(capture);
+	            if (returnCode == -1)
+	                return -1;
+	            if (returnCode == 1)
+	                return 0;
+	        }
+	    }
+	return 0;
+	}else{
+	    while (count-- > 0) {
+	        for (;;) {
+	            int returnCode=read_frame_v4l2(capture);
+	            if (returnCode == -1)
+	                return -1;
+	            if (returnCode == 1)
+	                return 0;
+			}
+   		}
+	return 0;
+	}
 }
 
 static int icvGrabFrameCAM_V4L(CvCaptureCAM_V4L* capture) {
@@ -1420,7 +1514,7 @@
 
     case CV_CAP_PROP_POS_MSEC:
         if (capture->FirstCapture) {
-            return 0;
+            return 1000*capture->timestamp.tv_sec+((double)capture->timestamp.tv_usec)/1000;
         } else {
             //would be maximally numerically stable to cast to convert as bits, but would also be counterintuitive to decode
             return 1000 * capture->timestamp.tv_sec + ((double) capture->timestamp.tv_usec) / 1000;
@@ -1848,7 +1942,7 @@
         }
         break;
     case CV_CAP_PROP_FPS:
-        struct v4l2_streamparm setfps;
+        struct v4l2_streamparm setfps; 
         memset (&setfps, 0, sizeof(struct v4l2_streamparm));
         setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
         setfps.parm.capture.timeperframe.numerator = 1;
@@ -1979,10 +2073,28 @@
 CvCapture* cvCreateCameraCapture_V4L( int index )
 {
     CvCaptureCAM_V4L_CPP* capture = new CvCaptureCAM_V4L_CPP;
+	changed_buffer_size=DEFAULT_V4L_BUFFERS;
 
     if( capture->open( index ))
         return (CvCapture*)capture;
 
+    delete capture;
+    return 0;
+}
+
+CvCapture* cvCreateCameraCapture_V4L_buffer_size( int index , int change_buffer_size, int buffer_size)
+{
+    CvCaptureCAM_V4L_CPP* capture = new CvCaptureCAM_V4L_CPP;
+	if(buffer_size>0){
+		changed_buffer_size=buffer_size;
+	}else if (buffer_size==0) {
+		changed_buffer_size=1;
+		SYNC_FETCH=1;
+	}else changed_buffer_size=DEFAULT_V4L_BUFFERS;
+	
+    if( capture->open( index ))
+        return (CvCapture*)capture;
+
     delete capture;
     return 0;
 }
Binary files opencv_old/modules/videoio/src/.cap_libv4l.cpp.swp and opencv/modules/videoio/src/.cap_libv4l.cpp.swp differ
diff -urPx build -x .git opencv_old/modules/videoio/src/precomp.hpp opencv/modules/videoio/src/precomp.hpp
--- opencv_old/modules/videoio/src/precomp.hpp	2019-12-20 16:47:34.961181075 +0900
+++ opencv/modules/videoio/src/precomp.hpp	2019-12-20 15:11:34.573597615 +0900
@@ -102,6 +102,7 @@
 };
 
 CvCapture * cvCreateCameraCapture_V4L( int index );
+CvCapture * cvCreateCameraCapture_V4L_buffer_size( int index,int change_buffer_size, int buffer_size );
 CvCapture * cvCreateCameraCapture_V4L( const char* deviceName );
 CvCapture * cvCreateCameraCapture_DC1394( int index );
 CvCapture * cvCreateCameraCapture_DC1394_2( int index );
